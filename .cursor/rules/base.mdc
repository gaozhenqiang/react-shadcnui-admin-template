---
alwaysApply: true
---

# 基础信息

组件库：ui.shadcn、Tailwind css

# 语言

中文，用中文回答问题

# 代码质量要求

1. 尽量复用已有类型，不要写相同的重复类型。
2. 一定要复用已有的组件，不能重复造轮子，先去 src/components 目录下找。
3. 代码必须符合组件库的设计规范，不能随意更改样式。
4. 代码必须符合 lint 规范，不能有 lint 错误。
5. 代码必须符合 prettier 规范，不能有 prettier 错误。
6. 代码必须符合 typescript 规范，不能有 typescript 错误。
7. 代码必须符合最佳实践，不能有性能问题。
8. 代码必须符合安全规范，不能有安全漏洞。
9. 代码必须符合可维护性规范，不能有难以维护的代码。
10. 代码必须符合可读性规范，不能有难以阅读的代码，代码注释要全。
11. 页面顶部要有注释，包含组件名称、功能描述，其它信息就没必要了。

# 创建 tsx 组件模板

- 组件名
  - index.tsx

## tsx：

```tsx
#set($processedFileName = ${NAME})
import {
  ForwardedRef,
  forwardRef,
  memo,
} from 'react';

export interface I${processedFileName}Ref {}

export interface I${processedFileName}Props {
}

const $processedFileName = memo(
  forwardRef(
    (
      {}: I${processedFileName}Props,
      ref: ForwardedRef<I${processedFileName}Ref>,
    ) => {
      return (
        <div></div>
      );
    },
  ),
);

export default ${processedFileName};
```

# 目录规范

一个页面要包含多个组件，只有这个页面用到的私有组件就放到这个页面的文件夹下面，如：

- pages
  - dashboard
    - index.tsx
    - components
      - chart
        - index.tsx
      - stats
        - index.tsx

如果一个组件是多个页面公用的，就放到 src/components 目录下，如：
- components
  - button
    - index.tsx
  - modal
    - index.tsx

如果一个页面或者组件，功能比较多，需要跨多个组件共享状态，那么一定到创建要给store来管理组件的状态，如：
- chat // chat组件或页面
  -- components // chat 组件私有组件
     - message-list
       -- index.tsx
     - message-input
       -- index.tsx
  -- index.tsx // chat 组件或页面主文件
  -- chatStore // 存放 chat 相关的 store
     - index.ts // chatStore 主文件
     - chatStore.utils.ts // chatStore 工具函数
     - chatStore.types.ts // chatStore 类型定义
     - chatStore.constants.ts // chatStore 常量定义

# store

## 普通 store

方法不需要写类型，只有属性写类型即可，然后方法写到 methods 里面。
这样方法类型可以自动推断，然后也可以在内部使用 methods.fn() 互相调用，并且类型安全。

```ts
import lodash from 'lodash'
import { create } from 'zustand'
import { combine } from 'zustand/middleware'

export interface IAccountStore {
  ...
}

const store: IAccountStore = {
  ...
}

function getStore() {
  return lodash.cloneDeep(store)
}

// 视频发布所有组件的共享状态和方法
export const useAccountStore = create(
  combine(
    {
      ...getStore(),
    },
    (set, get) => {
      const methods = {
        ...
      }
      return methods
    },
  ),
)
```

## 持久化 store

可以用封装的工具函数来创建持久化store：

/src/lib/store.ts

用法：

```ts
import { createPersistStore } from '@/lib/store'

export interface IUserStore {
  ...
}

const state: IUserStore = {
  ...
}

export const useUserStore = createPersistStore(
  {
    ...state,
  },
  (set, _get) => {
    const methods = {
      ...
    }

    return methods
  },
  {
    name: 'User',
  },
)
```

注意事项，注意，持久化的store使用了的 indexedDB，读取数据是异步的，需要通过_hasHydrated 来同步

```tsx
const {
  _hasHydrated,
} = usePublishDialogStorageStore(
  useShallow(state => ({
    _hasHydrated: state._hasHydrated,
  })),
)

useEffect(() => {
  if (_hasHydrated) {
    console.log('持久化数据同步完成')
  }
}, [_hasHydrated]);

```

## store 使用

使用useShallow，用于优化


```tsx
const {
  _hasHydrated,
} = usePublishDialogStorageStore(
  useShallow(state => ({
    _hasHydrated: state._hasHydrated,
  })),
)

```

# 注意事项

1. 每次开发功能必须要去 `src\components` 查看是否有可用的全局组件，不要重复开发。
2. 如果加了全局组件，必须在 `src\components\README.md` 添加文档。
3. 创建页面注意参考文档 `src\docs\开发注意事项.md`
4. 如果有表单，去 `src\lib\regulars.ts`找一下有没有对应的正则校验，最典型的，手机号、身份证号码。
5. 每次开发功能必须要去 `src\lib` 查看是否有可用的全局方法，不要重复开发。
6. 每次开发功能必须要去 `src\stores` 查看是否有可用的全局store，不要重复开发。
7. 如果加了全局store，必须在 `src\stores\README.md` 添加文档。
8. 如果加了全局方法，必须在 `src\lib\README.md` 添加文档。